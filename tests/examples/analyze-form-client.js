#!/usr/bin/env node
/**
 * ChromePilot Form Analyzer
 * Analyzes DOM tree to find form containers and extract all form elements with stable selectors
 * 
 * Usage:
 *   node analyze-form-client.js <url> [startSelector]
 * 
 * Examples:
 *   node analyze-form-client.js https://www.selenium.dev/selenium/web/web-form.html
 *   node analyze-form-client.js https://www.selenium.dev/selenium/web/web-form.html "form"
 *   node analyze-form-client.js https://github.com/login "input[type=text]"
 * 
 * Limitations:
 *   - None - works on all pages including CSP-restricted sites
 *   - Uses inspectElement API which works in CSP environments
 */

const ChromePilotClient = require('./chromepilot-client');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  
  // Foreground colors
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  gray: '\x1b[90m',
  
  // Background colors
  bgRed: '\x1b[41m',
  bgGreen: '\x1b[42m',
  bgYellow: '\x1b[43m',
  bgBlue: '\x1b[44m'
};

const c = {
  success: (str) => `${colors.green}${str}${colors.reset}`,
  error: (str) => `${colors.red}${str}${colors.reset}`,
  warning: (str) => `${colors.yellow}${str}${colors.reset}`,
  info: (str) => `${colors.cyan}${str}${colors.reset}`,
  dim: (str) => `${colors.gray}${str}${colors.reset}`,
  bold: (str) => `${colors.bright}${str}${colors.reset}`,
  code: (str) => `${colors.magenta}${str}${colors.reset}`,
  highlight: (str) => `${colors.bgBlue}${colors.white}${str}${colors.reset}`
};

class FormAnalyzer {
  constructor() {
    this.client = new ChromePilotClient();
    this.sessionId = null;
  }

  async connect() {
    await this.client.connect();
    this.sessionId = this.client.sessionId;
  }

  /**
   * Find semantic container from parent hierarchy
   */
  findSemanticContainer(parents) {
    // Priority order: form > [role] > [id] > semantic tags > class-based
    // Search from closest parent (index 0) outward
    for (let i = 0; i < parents.length; i++) {
      const parent = parents[i];
      
      // 1. Form elements (highest priority)
      if (parent.tagName === 'form') {
        console.log(`  ${c.success('‚úì')} Found FORM container: ${c.code(parent.selector)}`);
        return parent;
      }
    }
    
    // Second pass for other semantic containers
    for (let i = 0; i < parents.length; i++) {
      const parent = parents[i];
      
      // 2. ARIA roles
      if (parent.attributes.role) {
        const role = parent.attributes.role;
        if (['form', 'dialog', 'main', 'region'].includes(role)) {
          console.log(`  ‚úì Found container with role="${role}": ${parent.selector}`);
          return parent;
        }
      }
      
      // 3. ID-based containers
      if (parent.attributes.id) {
        const id = parent.attributes.id.toLowerCase();
        if (id.includes('form') || id.includes('dialog') || id.includes('modal') || id.includes('container')) {
          console.log(`  ‚úì Found container with id: ${parent.selector}`);
          return parent;
        }
      }
      
      // 4. Semantic HTML tags
      if (['main', 'section', 'article', 'aside', 'dialog'].includes(parent.tagName)) {
        console.log(`  ‚úì Found semantic container: <${parent.tagName}> ${parent.selector}`);
        return parent;
      }
      
      // 5. Meaningful class names
      const className = parent.attributes.class || '';
      if (className.match(/\b(form|dialog|modal|container|wrapper|panel)\b/i)) {
        console.log(`  ‚úì Found container with class: ${parent.selector}`);
        return parent;
      }
    }
    
    // Fallback to first parent with ID
    const parentWithId = parents.find(p => p.attributes.id);
    if (parentWithId) {
      console.log(`  ‚ö† Using fallback (first parent with ID): ${parentWithId.selector}`);
      return parentWithId;
    }
    
    // Last resort: outermost parent
    console.log(`  ‚ö† Using fallback (outermost parent): ${parents[0].selector}`);
    return parents[0];
  }

  /**
   * Generate stable selector for an element (from inspectElement result)
   * Note: This is now mostly handled by _internal_generateSelector in dom-helper.js
   * which uses improved priority: id > radio/checkbox name+value > name > name+type > 
   * data-* > aria-label > type+placeholder > unique class
   */
  generateStableSelector(element) {
    // Element already has a selector generated by _internal_generateSelector
    // Just return it directly
    return element.selector;
  }

  /**
   * Find label for form element (from inspectElement result)
   */
  findLabel(element) {
    const { attributes } = element;
    const { id, placeholder, name } = attributes;
    
    // Check for explicit label association
    if (id) {
      return `label[for="${id}"]`;
    }
    
    // Check for placeholder
    if (placeholder) {
      return placeholder;
    }
    
    // For inputs, the name attribute might be descriptive
    if (name) {
      return name;
    }
    
    return null;
  }

  /**
   * Analyze form starting from a specific element
   */
  async analyzeForm(tabId, startSelector = 'form input, form button, form select, form textarea, form a, form label') {
    console.log(`\n${c.bold('üîç Starting form analysis...')}\n`);
    console.log(`${c.info('üìç Start selector:')} ${c.dim(startSelector)}\n`);
    
    // Step 1: Inspect starting element to get tree structure
    console.log(c.bold('Step 1: Inspecting element tree...'));
    const inspectResult = await this.client.sendRequest('callHelper', {
      tabId,
      functionName: 'inspectElement',
      args: [startSelector]
    });
    
    if (!inspectResult.value) {
      throw new Error('Failed to inspect element');
    }
    
    const tree = inspectResult.value;
    console.log(`  ${c.success('‚úì')} Clicked element: ${c.dim('<' + tree.clickedElement.tagName + '>')} ${c.code(tree.clickedElement.selector)}`);
    console.log(`  ${c.success('‚úì')} Found ${c.info(tree.parents.length)} parent(s)`);
    console.log(`  ${c.success('‚úì')} Found ${c.info(tree.children.length)} child(ren)\n`);
    
    // Step 2: Find semantic container
    console.log(c.bold('Step 2: Finding semantic container...'));
    const container = this.findSemanticContainer(tree.parents);
    console.log('');
    
    // Step 3: Extract all form elements from container
    console.log(c.bold('Step 3: Extracting form elements...'));
    
    let elements = [];
    
    try {
      const containerSelector = container.selector;
      
      // Use getContainerElements helper to extract all interactive elements in one call
      // This is CSP-compatible and much more efficient than looping
      // Include: form controls (input, button, select, textarea) + links (a) + labels
      const result = await this.client.sendRequest('callHelper', {
        tabId,
        functionName: 'getContainerElements',
        args: [containerSelector, 'input, button, select, textarea, a, label']
      });
      
      if (!result || !result.value) {
        throw new Error(`Failed to get elements from container: ${containerSelector}`);
      }
      
      elements = result.value;
    } catch (error) {
      console.log(`  ‚ö† Error extracting elements: ${error.message}`);
      throw new Error(`Failed to extract form elements: ${error.message}`);
    }
    
    if (elements.length === 0) {
      throw new Error(`No form elements found in container: ${container.selector}`);
    }
    
    console.log(`  ${c.success('‚úì')} Found ${c.highlight(' ' + elements.length + ' ')} form element(s)\n`);
    
    // Step 4: Generate stable selectors and organize by type
    console.log(c.bold('Step 4: Generating stable selectors...\n'));
    
    const analyzed = {
      container: {
        selector: container.selector,
        tagName: container.tagName,
        id: container.attributes.id || null,
        class: container.attributes.class || null
      },
      elements: elements.map(el => {
        const stableSelector = this.generateStableSelector(el);
        const label = this.findLabel(el);
        const attrs = el.attributes || {};
        
        return {
          selector: stableSelector,
          tagName: el.tagName,
          type: attrs.type || '',
          name: attrs.name || '',
          id: attrs.id || '',
          label: label,
          placeholder: attrs.placeholder || '',
          required: attrs.required === 'true' || attrs.required === '',
          disabled: attrs.disabled === 'true' || attrs.disabled === '',
          visible: true, // inspectElement only returns visible elements
          value: attrs.value ? (attrs.value.substring(0, 50) + (attrs.value.length > 50 ? '...' : '')) : '',
          textContent: el.textContent ? (el.textContent.substring(0, 50) + (el.textContent.length > 50 ? '...' : '')) : ''
        };
      })
    };
    
    // Step 5: Validate selectors by testing with highlightElement
    console.log(c.bold('Step 5: Validating selectors...'));
    const validationResults = [];
    
    for (const [index, element] of analyzed.elements.entries()) {
      const result = await this.client.sendRequest('callHelper', {
        tabId,
        functionName: 'highlightElement',
        args: [element.selector]
      });
      
      const matchCount = result.value;
      const isValid = matchCount === 1;
      
      // Check if selector is fragile (contains multiple nth-child)
      const nthChildCount = (element.selector.match(/:nth-child\(/g) || []).length;
      const isFragile = nthChildCount >= 3;
      
      validationResults.push({
        selector: element.selector,
        matchCount,
        isValid,
        tagName: element.tagName,
        type: element.type,
        isFragile
      });
      
      if (!isValid) {
        console.log(`  ${c.warning('‚ö†')} ${c.code(element.selector)} matches ${c.warning(matchCount)} elements (expected 1)`);
      } else if (isFragile) {
        console.log(`  ${c.warning('‚ö†')} ${c.dim('Fragile selector:')} ${c.code(element.selector)}`);
        console.log(`      ${c.dim('Consider adding id, name, or data-* attributes to make it more stable')}`);
      }
    }
    
    const validCount = validationResults.filter(r => r.isValid).length;
    const totalCount = validationResults.length;
    const fragileCount = validationResults.filter(r => r.isFragile).length;
    console.log(`  ${c.success('‚úì')} Validated ${c.info(totalCount)} selectors: ${c.success(validCount + ' unique')}, ${totalCount - validCount > 0 ? c.warning(totalCount - validCount + ' ambiguous') : c.dim('0 ambiguous')}`);
    if (fragileCount > 0) {
      console.log(`  ${c.warning('‚ö†')} ${c.warning(fragileCount)} fragile selector(s) detected (using nth-child paths)`);
    }
    console.log(`  ${c.dim('‚è≥ Keeping highlights visible for 5 seconds...')}\n`);
    
    // Wait 5 seconds before clearing highlights
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // Clear highlights
    await this.client.sendRequest('callHelper', {
      tabId,
      functionName: 'removeHighlights',
      args: []
    });
    
    analyzed.validation = {
      total: totalCount,
      unique: validCount,
      ambiguous: totalCount - validCount,
      fragile: fragileCount,
      results: validationResults
    };
    
    return analyzed;
  }

  /**
   * Display analysis results
   */
  displayResults(analysis) {
    console.log(c.dim('‚ïê'.repeat(80)));
    console.log(c.bold(c.info('üìã FORM ANALYSIS RESULTS')));
    console.log(c.dim('‚ïê'.repeat(80)));
    console.log('');
    
    console.log(c.bold('üì¶ Container:'));
    console.log(`   ${c.dim('Tag:')}      ${c.code('<' + analysis.container.tagName + '>')}`);
    console.log(`   ${c.dim('Selector:')} ${c.code(analysis.container.selector)}`);
    if (analysis.container.id) console.log(`   ${c.dim('ID:')}       ${c.info(analysis.container.id)}`);
    if (analysis.container.class) console.log(`   ${c.dim('Class:')}    ${c.dim(analysis.container.class)}`);
    console.log('');
    
    // Display validation summary
    if (analysis.validation) {
      const { total, unique, ambiguous, fragile } = analysis.validation;
      const percentage = ((unique / total) * 100).toFixed(1);
      console.log(c.bold(percentage === '100.0' ? c.success('‚úÖ Selector Validation:') : c.warning('‚úÖ Selector Validation:')));
      console.log(`   ${c.dim('Total:')}     ${c.info(total)}`);
      console.log(`   ${c.dim('Unique:')}    ${percentage === '100.0' ? c.success(unique + ' (' + percentage + '%)') : c.info(unique + ' (' + percentage + '%)')}`);
      if (ambiguous > 0) {
        console.log(`   ${c.dim('Ambiguous:')} ${c.warning(ambiguous)}`);
      }
      if (fragile > 0) {
        console.log(`   ${c.dim('Fragile:')}   ${c.warning(fragile + ' (using nth-child paths)')}`);
      }
      console.log('');
    }
    
    console.log(c.bold('üìù Form Elements:'));
    console.log('');
    
    // Group by type
    const grouped = {};
    for (const el of analysis.elements) {
      const key = el.type || el.tagName;
      if (!grouped[key]) grouped[key] = [];
      grouped[key].push(el);
    }
    
    for (const [type, elements] of Object.entries(grouped)) {
      console.log(`  ${c.info(type.toUpperCase())} ${c.dim('(' + elements.length + ')')}:`);
      for (const el of elements) {
        // Check if selector is validated
        const validation = analysis.validation?.results.find(r => r.selector === el.selector);
        const validationMark = validation ? (validation.isValid ? c.success('‚úì') : c.warning(`‚ö†(${validation.matchCount})`)) : '';
        const fragileMark = validation?.isFragile ? c.warning(' ‚ö†fragile') : '';
        
        console.log(`    ${validationMark ? validationMark + ' ' : ''}${c.dim('‚Ä¢')} ${c.code(el.selector)}${fragileMark}`);
        if (el.label) console.log(`      ${c.dim('Label:')} ${el.label}`);
        if (el.name) console.log(`      ${c.dim('Name:')} ${el.name}`);
        if (el.placeholder) console.log(`      ${c.dim('Placeholder:')} ${el.placeholder}`);
        if (el.required) console.log(`      ${c.warning('‚ö† Required')}`);
        if (el.disabled) console.log(`      ${c.dim('üö´ Disabled')}`);
        if (!el.visible) console.log(`      ${c.dim('üëÅÔ∏è Hidden')}`);
        if (el.value) console.log(`      ${c.dim('Value:')} ${el.value}`);
        if (el.textContent && el.tagName === 'button') console.log(`      ${c.dim('Text:')} ${el.textContent}`);
        console.log('');
      }
    }
    
    console.log(c.dim('‚ïê'.repeat(80)));
    console.log('');
    console.log(c.bold('üí° Usage Example:'));
    console.log('');
    console.log(c.dim('```javascript'));
    console.log(c.dim('// Fill form using stable selectors:'));
    for (const el of analysis.elements.slice(0, 5)) {
      if (el.tagName === 'input' && el.type !== 'submit' && el.type !== 'button') {
        console.log(c.dim(`await client.callHelper('typeText', ['${el.selector}', 'value', true]);`));
      } else if (el.tagName === 'button' || el.type === 'submit') {
        console.log(c.dim(`await client.callHelper('clickElement', ['${el.selector}']);`));
      }
    }
    console.log(c.dim('```'));
    console.log('');
  }

  async close() {
    if (this.client) {
      this.client.close();
    }
  }
}

// Main execution
async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0 || args[0] === '--help' || args[0] === '-h') {
    console.log('');
    console.log(c.bold(c.info('ChromePilot Form Analyzer')));
    console.log(c.dim('‚ïê'.repeat(80)));
    console.log('');
    console.log('Analyzes web page forms and generates stable CSS selectors for automation.');
    console.log('');
    console.log(c.bold('Usage:'));
    console.log(c.dim('  node analyze-form-client.js <url> [startSelector]'));
    console.log('');
    console.log(c.bold('Arguments:'));
    console.log(`  ${c.info('url')}            URL to analyze`);
    console.log(`  ${c.info('startSelector')}  CSS selector to start analysis from (optional)`);
    console.log(`                 ${c.dim('Default: "form input, form button, form select, form textarea"')}`);
    console.log('');
    console.log(c.bold('Examples:'));
    console.log(c.dim('  node analyze-form-client.js https://www.selenium.dev/selenium/web/web-form.html'));
    console.log(c.dim('  node analyze-form-client.js https://www.selenium.dev/selenium/web/web-form.html "form"'));
    console.log(c.dim('  node analyze-form-client.js https://github.com/login "input[type=text]"'));
    console.log('');
    process.exit(0);
  }
  
  const url = args[0];
  const startSelector = args[1] || 'form input, form button, form select, form textarea';
  
  const analyzer = new FormAnalyzer();
  
  try {
    console.log('');
    console.log(c.bold(c.info('üöÄ ChromePilot Form Analyzer')));
    console.log(c.dim('‚ïê'.repeat(80)));
    
    // Connect to ChromePilot
    console.log(`\n${c.info('üì° Connecting to ChromePilot...')}`);
    await analyzer.connect();
    console.log(c.success('‚úì Connected\n'));
    
    // Open tab
    console.log(`${c.info('üåê Opening URL:')} ${c.dim(url)}`);
    const openResult = await analyzer.client.sendRequest('openTab', {
      url,
      focus: true
    });
    const tabId = openResult.tab.id;
    console.log(`${c.success('‚úì Tab opened')} ${c.dim('(ID: ' + tabId + ')\n')}`);
    
    // Wait for page to load
    console.log(c.info('‚è≥ Waiting for page to load...'));
    await new Promise(resolve => setTimeout(resolve, 2000));
    console.log(c.success('‚úì Page loaded\n'));
    
    // Analyze form
    const analysis = await analyzer.analyzeForm(tabId, startSelector);
    
    // Display results
    analyzer.displayResults(analysis);
    
    // Output JSON for programmatic use
    console.log(c.bold('üìÑ JSON Output:'));
    console.log(c.dim(JSON.stringify(analysis, null, 2)));
    console.log('');
    
    // Close the tab
    console.log(c.info('üßπ Closing tab...'));
    await analyzer.client.sendRequest('closeTab', { tabId });
    console.log(c.success('‚úì Tab closed\n'));
    
  } catch (error) {
    console.error(`\n${c.error('‚ùå Error:')} ${error.message}`);
    console.error(c.dim(error.stack));
    process.exit(1);
  } finally {
    analyzer.close();
    // Force exit immediately after closing
    process.exit(0);
  }
}

// Run if executed directly
if (require.main === module) {
  main().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

module.exports = FormAnalyzer;
